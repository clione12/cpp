# cpp02_notebook

## 整数类型

- 整数类型
    - 二进制，八进制，十六进制回顾
    - sizeof
    - 溢出问题以及取值范围
- 其他整数类型
    - char
        - 8bit，可以是有符号或者无符号
    - bool
        - 本质上就是char，额外定义了true和false的字面量而已
        - 8 bit
    - size_t
        - 用来表示内存大小的，32bit的无符号整数
        - 现代的系统表示内存不一定够用，但是有虚拟内存..?
    - <cstdint>
        - 比较方便，定义特定的类型和最大最小值

## 浮点数

- 浮点数
    - 单精度浮点类型，在内存中是如何表示的？
        
        ```c
        | 1位符号位 (S) | 8位指数位 (E) | 23位尾数位 (M) |
        ```
        
        具体的可以看例子
        
    - 浮点数的比较
        
        ```c
        float f1 = 23400000000;
        float f2 = f1 + 10; // but f2 = f1
        ```
        
        cpp中，两个数字是否相等，是看其二进制表示是否相等。这里因为精度问题，这俩的二进制表示是相同的。因此正确的判断方式是
        
        ```c
        if (f1 == f2) //bad
        if (fabs(f1 - f2) < FLT_EPSILON) // good
        ```
        
    - nan&inf

- 算数运算符
    - 字面量的定义
        
        ```cpp
        // 八进制
        0123
        // 十六机制
        0x5F
        
        //整数
        12u
        12l
        12ul
        12lu
        
        // 浮点数
        3.14  // doubule 类型
        3.14f  // float 类型
        3.14l
        
        ```
        
    - const
    - auto c++11的标准，自动指定类型
        - auto指定的类型指定下来，后续是不会改变的
    - 运算符
        - 单目运算符，移位运算符
        - 双目运算符
        - 赋值运算符，比较b= a++和b= ++a
        - 特别注意1：如果要进行浮点运算，字面量里面应该至少有一个浮点数
        - 特别注意2：运算类型只有四种，分别是double，float，long，int，即char运算不会有溢出的问题；规则是：操作数里面有一个上级类型，则转为上级运算类型

- **typedef**
    - 在c和cpp中的**为现有的数据类型定义一个新的名称（别名）**
    - 比如有点c标准中没有bool类型，可以自己定义个
        
        ```c
        typedef int bool;  // 定义 bool 为 int
        #define true 1
        #define false 0
        
        int main() {
            bool flag = true;
            if (flag) {
                printf("Flag is true.\n");
            }
            return 0;
        }
        ```
        

- 其他
    - 编译的时候，如果有warning，一定要去看看
    - c和c++这种语言，本身预设了开发者是熟悉计算机底层的，这就是效率的代价

QA

- 回顾下16进制
    - 如何表示
    
    ```bash
    # 一般使用0x的前缀表示
    # 0 1 2 3 4 5 6 7 8 9 A B C D E F
    # 0x1F代表31（1*16^1+15*16^0）
    
    # 使用场景
    # 内存地址 address: 0xFFFFFFF0
    # 颜色编码 color: #FF5733 分别代表RGB三个通道的颜色值0-255
    ```
    
    - 十六进制和二进制之间如何转换，举例子说明下
        
        简单来说，十六进制中的一个数，可以替换为4个二进制的bit，反之也可以
        

- 二进制本质上为什么能表示十进制？
    
    因为二进制本身可以表示可能性。比如32bit，可以表示2^32个可能性，按照一定的规则，一定能组合出2^32个数。
    

- 回顾下整数的取值返回
    - int【一般】是32位，你需要使用sizeof来确定，因为在不同的数据标准中是不一样的
    - 一般常用的就是，int，short，long，用sizeof来确定即可

- sizeof为什么是个操作符
    - 因为函数的参数一定是个变量

- 为什么bool b2 = -256是合法的
    - 虽然bool本质上是用一个字节来存储的，但是c++11中有个机制，即非0的会变为1，所以这里给啥不是0的都是合法的（一会验证下）

- 为什么1.2*10^15打印出来不是预期的结果（保留15位的小数）？
    - 因为浮点数的计算是有误差的，本质上是因为二进制表达的浮点数是有精度的

- 二进制表达的数字为什么有精度？
    - 同上，本质上还是因为二进制表达的是可能性。[0,1]中有无数种可能性，因此，一定要限制精度，不能无限细分下去

- 浮点数在内存中是怎么表示的，以及为什么会是这样表示的呢
    
    $$
    \text{Value} = (-1)^{\text{sign}} \times (1 + \text{fraction}) \times 2^{\text{exponent} - 127}
    $$
    
    - 一个bit表示sign
    - 8个bit表示exponent
    - 剩余的23bit表示fraction，比如1+0.5+0.25….

- 为什么一般来讲，浮点数的运算会比整数的运算要慢呢？比如芯片的架构是arm
    - 浮点运算本身需要考虑指数对齐，运算本身上是比整数运算复杂
    - 浮点运算单元是和整数运算单元分开的，算力应该是有限的
    - 浮点运算的指令集需要更多的时钟周期来完成
    - 浮点数的占用内存大小一般更大，因此需要更多的时间来访问
    - 更多的理解需要去深入**了解计算机体系结构相关的原理**

- 一个浮点数a(2.34e10f)，加一个值(10)b，为什么大小不变？a-b=0
    - 还是精度问题，二进制能表达的数字是有限的，因此，如果一个比较大的浮点数，采样间隔也是比较大的

- 具体去实验一下一些运算符，比如取反（2），and，or，xor，移动位数操作，并且看看用这些运算符的例子
    - 一般来说，移动位数的速度比乘法和除法快，但是有编译器优化，速度应该差不多，可以做实验来试一下吧