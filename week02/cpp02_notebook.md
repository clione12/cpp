# cpp02_notebook

- 整数类型
    - 二进制，十六进制回顾
    - 溢出问题以及取值范围
- 其他整数类型
    
    了解他们的取值范围
    
    - char
    - bool
        - 本质上就是char，额外定义了true和false的字面量而已
    - size_t
        - 用来表示内存大小的
    - <cstdint>
        - 比较方便，定义特定的类型和最大最小值

- 浮点数
    - float 32
    - double 64
    - 浮点数精度问题
    - 判断两个浮点数是否相等
    - nan&inf

- 算数运算符
    - 字面量的定义
        
        ```cpp
        // 八进制
        0123
        // 十六机制
        0x5F
        
        //整数
        12u
        12l
        12ul
        12lu
        
        // 浮点数
        3.14  // doubule 类型
        3.14f  // float 类型
        3.14l
        
        ```
        
    - const
    - auto c++11的标准，自动指定类型
        - auto指定的类型指定下来，后续是不会改变的
    - 运算符
        - 单目运算符，移位运算符
        - 双目运算符
        - 赋值运算符，比较b= a++和b= ++a
        - 特别注意1：如果要进行浮点运算，字面量里面应该至少有一个浮点数
        - 特别注意2：运算类型只有四种，分别是double，float，long，int，即char运算不会有溢出的问题；规则是：操作数里面有一个上级类型，则转为上级运算类型

- 其他
    - 编译的时候，如果有warning，一定要去看看
    - c和c++这种语言，本身预设了开发者是熟悉计算机底层的，这就是效率的代价

QA

- 回顾下16进制
    - 如何表示
    
    ```bash
    # 一般使用0x的前缀表示
    # 0 1 2 3 4 5 6 7 8 9 A B C D E F
    # 0x1F代表31（1*16^1+15*16^0）
    
    # 使用场景
    # 内存地址 address: 0xFFFFFFF0
    # 颜色编码 color: #FF5733 分别代表RGB三个通道的颜色值0-255
    ```
    
    - 十六进制和二进制之间如何转换，举例子说明下
        
        简单来说，十六进制中的一个数，可以替换为4个二进制的bit，反之也可以
        

- 二进制本质上为什么能表示十进制？
    
    因为二进制本身可以表示可能性。比如32bit，可以表示2^32个可能性，按照一定的规则，一定能组合出2^32个数。
    

- 回顾下整数的取值返回
    - int【一般】是32位，你需要使用sizeof来确定，因为在不同的数据标准中是不一样的
    - 一般常用的就是，int，short，long，用sizeof来确定即可

- sizeof为什么是个操作符
    - 因为函数的参数一定是个变量

- 为什么bool b2 = -256是合法的
    - 虽然bool本质上是用一个字节来存储的，但是c++11中有个机制，即非0的会变为1，所以这里给啥不是0的都是合法的（一会验证下）

- 为什么1.2*10^15打印出来不是预期的结果（保留15位的小数）？
    - 因为浮点数的计算是有误差的，本质上是因为二进制表达的浮点数是有精度的

- 二进制表达的数字为什么有精度？
    - 同上，本质上还是因为二进制表达的是可能性。[0,1]中有无数种可能性，因此，一定要限制精度，不能无限细分下去

- 浮点数在内存中是怎么表示的，以及为什么会是这样表示的呢
    
    $$
    \text{Value} = (-1)^{\text{sign}} \times (1 + \text{fraction}) \times 2^{\text{exponent} - 127}
    $$
    
    - 一个bit表示sign
    - 8个bit表示exponent
    - 剩余的23bit表示fraction，比如1+0.5+0.25….

- 为什么一般来讲，浮点数的运算会比整数的运算要慢呢？比如芯片的架构是arm
    - 浮点运算本身需要考虑指数对齐，运算本身上是比整数运算复杂
    - 浮点运算单元是和整数运算单元分开的，算力应该是有限的
    - 浮点运算的指令集需要更多的时钟周期来完成
    - 浮点数的占用内存大小一般更大，因此需要更多的时间来访问
    - 更多的理解需要去深入了解计算机体系结构相关的原理

- 一个浮点数a(2.34e10f)，加一个值(10)b，为什么大小不变？a-b=0
    - 还是精度问题，二进制能表达的数字是有限的，因此，如果一个比较大的浮点数，采样间隔也是比较大的

- 具体去实验一下一些运算符，比如取反（2），and，or，xor，移动位数操作，并且看看用这些运算符的例子
    - 一般来说，移动位数的速度比乘法和除法快，但是有编译器优化，速度应该差不多，可以做实验来试一下吧